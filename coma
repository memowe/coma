#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::Util 'trim';
use Text::Markdown 'markdown';
use Graph::Centrality::Pagerank;
use FindBin '$Bin';

use lib "$Bin/lib";
use Coma::Data;

# Prepare data access
helper data => sub {
    my $data_fn = $ENV{COMA_DATA_FILE} // app->home->rel_file('data/data');
    state $data = Coma::Data->new(data_filename => $data_fn);
    return $data;
};

# Markdown helper
helper markdown => sub {
    my ($c, $text) = @_;
    return markdown $text;
};

# Pagerank helper: expects LoL of vertex names
my $pr = Graph::Centrality::Pagerank->new();
helper calculate_pagerank => sub {
    my ($c, @graph) = @_;
    return $pr->getPagerankOfNodes(listOfEdges => \@graph);
};

# Completion helper: expects a callback returning a source data list
# and works on the term param
helper completion => sub {
    my ($c, $source_cb) = @_;
    my $term = $c->param('term');

    # Incomplete request
    unless (defined $term) {
        $c->res->code(400);
        return $c->render(text => 'No term given');
    }

    # Find matches
    my @matches = sort grep {/\Q$term\E/} $source_cb->();

    # Render as json
    return $c->render(json => \@matches);
};

# JSON entity completion
any '/entity_completion' => sub {
    my $c = shift;
    return $c->completion(sub {@{$c->data->get_entities}});
};

# JSON connection completion
any '/connection_completion' => sub {
    my $c = shift;
    return $c->completion(sub {keys %{$c->data->get_connection_types}});
};

# Home: show all maps 'n' stuff
get '/' => sub {
    my $c = shift;

    # Retrieve all maps
    my $map_ids = $c->data->get_all_map_ids;
    my @maps    = map {$c->data->get_map_data($_)} @$map_ids;

    # Done
    $c->stash(maps => \@maps);
} => 'home';

# Add a map
post '/' => sub {
    my $c = shift;

    # Create the map
    my $map = $c->db('Map')->create({
        name        => $c->param('name'),
        description => $c->param('description'),
    });

    # Done
    $c->redirect_to('show_map', map_id => $map->id);
} => 'add_map';

# Show entity cloud
get '/entities' => sub {
    my $c = shift;

    # Load entities (including degree)
    my $entities = $c->db('Entity');

    # Calculate reverse pagerank
    my $pagerank = $c->calculate_pagerank(
        map [$_->to_name => $_->from_name] => $c->db('Connection')->all
    );

    # Done
    $c->stash(
        entities    => $entities,
        pagerank    => $pagerank,
    );
} => 'entities';

# Show entity data
get '/entity/:entity_name' => sub {
    my $c   = shift;
    my $en  = $c->param('entity_name');

    # Try to retrieve entity
    my $entity = $c->db('Entity')->search({name => $en})->first;
    return $c->render_not_found unless $entity;

    # Get degree
    my $degree = $entity->degree;

    # Get directed degrees
    my $from_deg = $entity->from_degrees->get_column('from_degree')->sum // 0;
    my $to_deg   = $entity->to_degrees->get_column('to_degree')->sum // 0;

    # Get neighbourhood
    my $from_ent = $entity->from_connections->search_related('to_entity',
        undef, {distinct => 1}
    );
    my $to_ent   = $entity->to_connections->search_related('from_entity',
        undef, {distinct => 1}
    );

    # Calculate reverse pagerank
    my $pagerank = $c->calculate_pagerank(
        map [$_->to_name => $_->from_name] => $c->db('Connection')->all
    );

    # Find all maps with this entity
    my $maps = $entity->maps->search(undef, {distinct => 1});

    # Done
    $c->stash(
        degree          => $degree,
        from_degree     => $from_deg,
        to_degree       => $to_deg,
        from_neighbours => $from_ent,
        to_neighbours   => $to_ent,
        pagerank        => $pagerank,
        maps            => $maps,
    );
} => 'show_entity';

# Under here: work on one map
under '/map/:map_id' => [map_id => qr/\d+/] => sub {
    my $c = shift;

    # Try to load map
    my $map = $c->db('Map')->find($c->param('map_id'), {
        prefetch => 'connections',
        order_by => [qw(connections.from_name connections.to_name)],
    });
    $c->render_not_found and return unless $map;

    # Ok, we have a map
    $c->stash(map => $map);
    return 1;
};

# Show one map
get '/' => sub {
    my $c   = shift;
    my $map = $c->stash('map');

    # Load entities of this map
    my $entities = $map->map_entities;

    # Calculate reverse pagerank
    my $pagerank = $c->calculate_pagerank(
        map [$_->to_name => $_->from_name] => $map->connections->all
    );

    # Done
    $c->stash(
        entities => $entities,
        pagerank => $pagerank,
    );
} => 'show_map';

# Edit map meta data
post '/edit' => sub {
    my $c   = shift;
    my $map = $c->stash('map');

    # Update map meta data
    $map->update({
        name        => $c->param('name'),
        description => $c->param('description'),
    });

    # Done
    $c->redirect_to('show_map');
} => 'edit_map';

# Add a connection
post '/' => sub {
    my $c   = shift;
    my $map = $c->stash('map');

    # Insert a new connection for this map
    $map->create_related('connections', {
        from_name   => trim($c->param('from')),
        type        => trim($c->param('type')),
        to_name     => trim($c->param('to')),
    });

    # Done
    $c->redirect_to('show_map');
} => 'add_connection';

# Delete a connection
post '/delete_connection' => sub {
    my $c   = shift;
    my $map = $c->stash('map');

    # Delete all matching connections (<= 1)
    $map->delete_related('connections', {
        from_name   => $c->param('from'),
        type        => $c->param('type'),
        to_name     => $c->param('to'),
    });

    # Done
    $c->redirect_to('show_map');
};

# Delete a map
post '/delete' => 'delete_map';

# Delete a map and the user is sure
post '/delete_sure' => sub {
    my $c = shift;

    # Delete it
    my $map = $c->stash('map');
    $map->delete_related('connections');
    $map->delete;

    # Done
    $c->redirect_to('home');
} => 'delete_map_sure';

# TGF export of one map
app->types->type(tgf => 'text/plain;charset=UTF-8');
get '/tgf_export' => sub {
    my $c = shift;

    # Force download
    my $fn = $c->stash('map')->name . '.tgf';
    $c->res->headers->content_disposition("attachment; filename=$fn");

    # Render TGF template
    $c->render(format => 'tgf');
};

app->start;
